[narrator]: Once upon a time, there once was a sandwich named Mr. Salami Sandwich. He was made from two pieces of sourdough bread and had salami in the middle of his body.
[mss]: Today I am buying a motorhome. I plan to drive a across the country.
[man1]: Hi there! Did you want to rent an RV?
[mss]: Yes. A big one.
[man1]: Sounds good. Here are your keys. Where are you heeaded?
[mss]: I am going to San Francisco.
[man1]: Oh, the Golden Gate Bridge is there! You should visit it. It is a beautiful marvel of engineering.
[mss]: Thanks for the tip. I will do that.
[man1]: You're welcome! Good luck on your trip!
[mss]: Thanks!
[sound: female voice]
[sound: male voice] "They'll keep testing until they find something that kills me." ―Animal rights activist
[sound: male voice] "Stop testing!" ―Animal rights activist
[sound: male voice] "You're killing me!" ―Animal rights activist
[ # animal_rights_activist ] = { name = 'Doug Rattmann' ; behavior = function () { return { wander = function () { print ( 'Movement instructions received.' ); direction = 
[ 0 , 1 ]; last_location = getpos (); while (!( location == last_location )) direction += 1 ; setpos ( location ); }; }; }; } Here I used some generic behaviour code based on states and events by Thorbjørn Lindeijer & Robin De Jongh , which gives us access to functions like setpos() which returns the current position vector belonging to an entity and getpos() which takes such vector as argument and updates its own value accordingly after having moved it around according if required by state changes/events during execution time. By using such behaviours script writers can focus on specifying behaviours instead of programming low-level movement details themselves; especially when working within short deadlines where high-level control flow decisions need careful consideration otherwise things may easily spiral out of hand quickly . Now back onto our Animal Rights Activist friend... What kind(s) behaviour(s) shall he have? If we had chosen priorities or nonstandard mechanics earlier , then defining specific behaviour scripts would be easier because now we already know how much extra work needs to be done beforehand so that everything works together nicely afterwards . But since we didn't yet decide anything about stuff like priorities or nonstandard mechanics so far... Well, let's start simple with standard AI routines : * Idle * Attacking * Fleeing These kinds(groups) behave pretty much self explanatory; i ndeed most implementations will take care automatically handling all kinds whenever appropriate conditions exist while others might allow scripting explicit choices e xplicitly by s cript k ierwians whenever such conditions are met o r not met respectively However... Let us assume that our Animal Rights Activist has well earned his place among other NPCs ... So maybe more than just three kinds/groups will do? Since placing character players into certain groups upon encountering them isn't always possible without preprocessing game data files first (i e., hardcoding group definitions ingame ), let us assume these groups are defined manually instead : 
[ # love_for_animals ] = { name = 'Love for Animals' ; behaviorType = function () { return 
[ B A T C H _ P R E S S U R E ]; } }, \ 
[ # anti _ experiments ]={ name='Anti Experiments'; behaviorType=function(){return
[B A T C H _ P R E S S U R E];}}, \ --and-- 
[#experimentation]={name='Experimentation';behaviorType=function(){return
[B A T C H _ P R E S S U RE];}}; Note that internally those groups share many similarities concerning typical behaviour patterns across various game genres including RPG s & MMO s −− but have distinctive requirements regarding gameplay dynamics depending on mission objectives during specific phases within campaign scenarios too −− therefore grouping behavioural aspects into separate set s is essential fo r satisfying player expectations later when applied correctly As usual there are several ways applying associations between player character entities can be achieved technically speaking ... We could either implement group definitions directly inside each NPC class definition itself along with tagging objects dynamically via templates at runtime based on discovered group memberships assigned previously via special abilities granted by ability templates Or else directly specify group tag values inside NPCs database entries whenever applicable −− yet without any support f rom abili ty t emplates whatsoever Of course if none o f th ese meth ods meet y our needs sufficiently well then d efin ing custom database entries f o r storing g ro up tag values right away might be useful here − b ut remember th at some erros might occur during transition s later resulting in incorrect g rou p tagging anyway To learn more about template based functionality check out my Template Design Pattern Tutorial series ... Anyway back onto our topic here ... What kind(s) behaviour(s) shall he have ? Again remember th at deciding th ese things depends heavily on specific game genre requirements But since Doug has already been modelled in one way or another before writing these lines down , let us reuse his model again instead of recreating him from scratch each time : static const std :: map < std :: string , std :: pair < std :: string , std :: vector < std :: string >>> IMPLICIT TAGS 
[]={ // template tags // note that implicit tags cannot contain whitespace!!! {" attack ", {{ "throw molotov cocktail" , "call friend for help" }}}, {" flee ", {{ "hide behind car" }}}, {" idle ", {{}}} // tags explicitly defined outside implicit tag map above }; static const unsigned int DEFAULT_TAGS 
[]={ 3 }; Basically every NPC object has got its own set containing pairs made up by key/value pairs where key labels correspondingly describe possible state transitions allowed within certain situations while value labels correspondingly comprise lists expressing potential actions associated with each state transition respectively Now back onto our topic here ... What kind(s
